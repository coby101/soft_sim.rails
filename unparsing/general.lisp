;;;============================================================
;;;
;;;   Code for general Ruby on Rails specific uparsing
;;;
;;;============================================================
 
(in-package #:rails-unparser)

(defun reserved-column-name? (name ent)
  ;; still need to add 0 to many (association_name)_type for relations
  ;; and 0 to many (table_name)_count for children
  (member
   name
   (list
    (strcat (snake-case (name ent)) "_id") ;; rail's default foreign key name
    "id"                                   ;; rail's default for primary key
    "type"                                 ;; column name used for a polymorphic reference
    "lock_version"                         ;; Adds optimistic locking to a model
    "updated_at"                           ;; rail's default modification timestamp
    "created_at"                           ;; rail's default creation timestamp
    )))

(defun make-indent ()
  (ruby:make-indent))

(defun comment-out (stream str &rest args)
  (apply #'ruby:comment-out stream str args))

(defun format-file-notice (stream function)
  (let* ((len (+ 2 (length function)))
         (hash-pad (make-string len :initial-element #\#))
         (space-pad (make-string len :initial-element #\Space)))
    (comment-out stream "~
###########################~a######################################## #
this file was generated by ~s. If you modify this file, please remove #
this header to make clear the generated content is now obsolete.~a    #
###########################~a######################################## #"
;               (local-time:format-timestring nil (local-time:now)
;                    :format *documentation-timestamp-format*)
               hash-pad function space-pad hash-pad)))

(defun indent-block (stream str &rest args)
  (apply #'ruby:indent-block stream str args))

(defun comment-with-warning (stream str &rest args)
  (apply #'ruby:comment-with-warning stream str args))

(defmethod schema-name ((obj t))
  (error "no schema-name method written for ~a" (type-of obj)))

(defmethod instance-name ((obj t))
  (error "no instance-name method written for ~a" (type-of obj)))

(defmethod instance-name ((rel relation))              (format nil "~a~p" (snake-case (name rel)) (or (multiplicity-max rel) 2)))
(defmethod instance-name ((att attribute))             (schema-name att))
(defmethod instance-name ((att primary-key))           "id")
(defmethod instance-name ((att composite-primary-key)) "id")
(defmethod instance-name ((ent entity))                (snake-case (name ent)))
(defmethod instance-name ((str string))                (snake-case str))
(defmethod model-plural ((obj t)) (snake-case (plural obj)))

(defmethod model-name ((att attribute)) (model-name (my-entity att)))
(defmethod model-name ((ent entity))    (camel-case (name ent)))
(defmethod model-name ((rel relation))  (camel-case (name (entity rel))))
(defmethod model-name ((str string))    (camel-case str))

(defmethod schema-name ((ref list))
  (if (field-reference-spec? ref)
      (strcat (snake-case (name (car ref))) "_"
              (if (= (length (cdr ref)) 1)
                  (schema-name (cadr ref))
                  (schema-name (cdr ref))))
      (error "can not handle ~a" ref)))
(defmethod schema-name ((att composite-primary-key)) "id")
(defmethod schema-name ((rel relation))              (snake-case (plural rel)))
(defmethod schema-name ((ent entity))                (snake-case (plural ent)))
(defmethod schema-name ((ent specialized-entity))    (schema-name (super ent)))
(defmethod schema-name ((att attribute))
  (let ((name (snake-case (name att))))
    (if (reserved-column-name? name (my-entity att))
        (strcat (schema-name (my-entity att)) "_" name) 
        name)))

(defmethod schema-name ((att foreign-key))
  (call-next-method))

(defmethod schema-name ((att primary-key))
  (call-next-method));"id")

(defmethod unparse ((obj list) (language (eql :ruby)))
  (if (and (= 2 (length obj))
           (field-reference-expression? obj)
           (or (eq (entity (car obj)) (my-entity (cadr obj)))
               (eq (car obj) (my-entity (cadr obj)))))
      (if (eq (entity (car obj)) (my-entity (cadr obj)))
          (format nil "~a_~a" (snake-case (name (car obj))) (schema-name (cadr obj))) 
          (unparse (cadr obj) language))
      (unparse obj language)))

(defmethod controller-name ((aspect aspect))
  (format nil "~a~aController"
          (if (name (view aspect))
            (strcat (name (view aspect)) "::")
            "")
          (camel-case (plural (entity aspect)))))

(defun implement-as-string? (att)
  (and (eql (data-type att) :boolean)
       (or (nullable? att)
           (not (default-value att)))))

(defmethod unparse ((obj entity) (language (eql :ruby)))
  ;; snake-case is a bit arbitrary but a common convention
  (schema-name obj))

(defmethod unparse ((obj attribute) (language (eql :ruby)))
  (snake-case (name obj)))

(defmethod unparse ((obj relation) (language (eql :ruby))) (call-next-method)); (unparse (keywordify (schema-name obj)) language))

(defmethod unparse-expression ((obj attribute) (language (eql :ruby)) &optional args)
  (when args
    (error "we shouldn't have any args here...? (~a)" args))
  (schema-name obj))

(defmethod unparse-expression ((operator (eql :rows)) (language (eql :ruby)) &optional args) 
  (let ((class (model-name (car args)))
        (where (if (cadr args)
                   (format nil ".where(\"~a\")" (unparse-expression (cadr args) :sql))
                   "")))
    (format nil "~a~a.count" class where)))

(defmethod unparse-expression ((operator (eql :unchanged)) (language (eql :ruby)) &optional args)
;; this check fails on ($literal "supplier_id")
;  (unless (or (typep (car args) 'string) (typep (car args) 'attribute))
;    (error "$UNCHANGED is only appropriate for an attribute expression"))
  (format nil "~a_change_to_be_saved == nil" (unparse-expression (car args) language)))

(defmethod unparse-expression ((operator (eql :new-value)) (language (eql :ruby)) &optional args)
  (format nil "~a" (unparse-expression (car args) language)))

(defmethod unparse-expression ((operator (eql :old-value)) (language (eql :ruby)) &optional args)
 ; (unless (or (typep (car args) 'string) (typep (car args) 'attribute))
 ;   (error "$OLD_VALUE is only appropriate for an attribute expression"))  
  (format nil "~a_change_to_be_saved ? ~:*~a_change_to_be_saved.first : ~:*~a" (unparse-expression (car args) language)))

(defmethod unparse-expression ((operator (eql :stop-delete)) (language (eql :ruby)) &optional args) 
  (format nil "errors.add(:~a, ~s)" (unparse (primary-key (my-entity (car args))) language)
          "deletion is not allowed"))

;;Record.count(:all, :conditions => {:created_at => start_date..end_date, :finished_at => nil })
(defmethod unparse-expression ((operator (eql :max-rows)) (language (eql :ruby)) &optional args)
  (unparse-expression
   :<= language (list (list :rows (car args) (caddr args)) (cadr args))))

(defmethod unparse-expression ((operator (eql :min-rows)) (language (eql :ruby)) &optional args)
  (unparse-expression
   :>= language (list (list :rows (car args) (caddr args)) (cadr args))))

(defmethod unparse-expression ((operator (eql :rows-eql)) (language (eql :ruby)) &optional args)
  (unparse-expression
   := language (list (list :rows (car args) (caddr args)) (cadr args))))

(defmethod unparse-expression ((operator (eql :as-money)) (language (eql :ruby)) &optional args)
  (format nil "number_to_currency(~a)" (unparse-expression (car args) language)))

(defmethod unparse-expression ((operator (eql :as-quantity)) (language (eql :ruby)) &optional args)
  (format nil "helper.number_with_precision(~a, :precision => 2, :delimiter => ',')"
          (unparse-expression (car args) language)))

(defmethod unparse-expression ((operator (eql :not-null)) (language (eql :ruby)) &optional args)
  (let ((field-var (unparse-expression (first args) language)))
    (format nil "~a.present?" field-var)))

(defmethod unparse-expression ((operator (eql :null)) (language (eql :ruby)) &optional args)
  (let ((field-var (unparse-expression (first args) language)))
    (format nil "~a.blank?" field-var)))

(defmethod unparse-attribute-value ((attribute attribute) (value t))
  (ruby:unparse-data (data-type attribute) value))

;  (format nil "~a~a"  (model-name source-entity)
;	        ;; note if test, fix when needed!
;	      (if (and filter nil) ".<state> or .where<expression goes here>" ""))))

(defun summary-arg (att)
  (if (eql (summary-type att) :count)
      ""
      ;; this will need more effort for calculated attributes etc
      (strcat ":" (schema-name (source att)))))

(defun summary-method (sum-type)
  (ecase sum-type
    (:count "size") ;; not "count", avoids a db query
    (:sum "sum")
    (:average "average")
    (:mean (or (warn "unknown summary method for :mean") "mean"))
    (:median (or (warn "unknown summary method for :median") "median"))
    (:range (or (warn "unknown summary method for :range") "range"))
    (:max "maximum")
    (:min "minimum")))

(defmethod unparse-summary-method ((att summary-attribute))
  (format nil "~a(~a)" (summary-method (summary-type att))
          (summary-arg att)))

(defmethod unparse-core-element ((item entity) (aspect aspect) &key (downlink? :always))
  (declare (ignorable aspect downlink?))
  ":id")

(defmethod unparse-core-element ((item primary-key) (aspect aspect) &key (downlink? :always))
  (declare (ignorable aspect downlink?))
  ":id")

(defmethod unparse-core-element ((item summary-attribute) (aspect aspect) &key (downlink? :always))
  (if (or (eql :count (summary-type item)) (eql downlink? :always))
      (format nil "{ ~a: { downlink: :~a } }" (schema-name item) (schema-name (my-entity (source item))))
      (call-next-method)))

(defmethod unparse-core-element ((item t) (aspect aspect) &key (downlink? :always))
  (declare (ignorable downlink?))
  (format nil ":~a" (schema-name item)))

;;;===========================================================================
;;; Local variables:
;;; tab-width: 4
;;; indent-tabs-mode: nil
;;; End:
